這章蠻短的，但一些程式蠻有問題。
主要概念就是輸入一個函數，
然後不斷執行直到條件滿足。

因此至少有三個參數，要運行的函數、初始值、條件。
sicp 中條件是給容許誤差，但之前某單元有做過類似的事，
有時用固定的誤差不太準，但改成比例誤差也會遇到例外。
我是寫成讓使用者輸入一個判斷函數，
自己判斷條件滿足了沒。

結果多數情況還是容許誤差已夠用，
只好再寫一個函數輸入容許誤差，
會返回判斷二數間距是否小於容許誤差函數的函數 `orz`


## search
因多項式為線性，故若 `f(a)` 為正且 `f(b)` 為負，
則至少存在一根 c 介於 a b 間。
於是就一直分成二區間，然後測試根在哪一區間，
直到區間 `|a-b|` 小於容許誤差，就返回 c。

這程式只能解出在 a b 區間中的一根，
如果有多個根會被忽略。

sicp 中把 `postive?` 和 `negative?` 獨立出來，
沒有直接在 `cond` 用 `<` `>` 比，
我還以為之後要在這上面做文章，
所以獨立出來重寫，結果也沒有。

## fixed-point
好像就翻不動點？
[[lambda 演算]] 中好像有同名的東西，
又叫 **Y combinator** 。

她的概念是要求 `f(x) = x` ，
作法則是直接不斷把 x 輸入到 f 函數，
然後再用輸出當下一個 x。
如果 f 收斂是可以啦，
但絕大多數的函數都不會收斂吧ㄎㄎ

### 管道
以前初入 lisp 系語言時寫過類似的幾個東西：

  - 管道：輸入多個函數 a b c d，返回一個函數 f，
    呼叫 f(x) 等同呼叫 d(c(b(a(x)))) 。
  - 重覆呼叫：輸入函數 f 和要求次數 n，
    返回一個函數 g，g(x) 等同對 x 不斷呼叫 f n 次。

原本 x 也是輸入，後來才由 curry 想到
其實可以直接返回包好的函數，方便多次調用。
另外原本第二個 *重覆呼叫* 是把 f 串成要求長度的 list，
再丟到第一個 *管道* 裡實作的 `;)`

那時候就寫了幾個簡單的函數，試試串起來會發生什麼事。
（像 `log` 、`*3` 、`+7` 之類的。）
結果好像因為串了 log，竟然會趨近某一值 `@@`

## 改寫迴圈與尾端遞迴
有幾題要求如果是用迴圈寫，
就改寫成尾端遞迴；反之亦同。
一開始還會寫，後來覺得其實沒什麼難度。
我是會要求自己儘量用尾端遞迴實作，
感覺再改回迴圈就沒什麼難度。
後面就有點懶得寫。

## 浮點數與整數轉換
sicp 還沒介紹轉換，
只簡單介紹只要是整數與浮點數的運算，
結果就會用浮點數表示。
有幾題程式比較複雜，
我竟然不能簡單看出來，放了浮點數初始值後，
會不會 *感染* 到所有結果。

結果試了，有成功，
只是懶得人腦 compile 驗證邏輯。


## cont-frac
這題是解 [[連分數]] (continued fraction) ，
寫得時候發現不能優雅的寫成尾端遞迴，
之後看了別人的 code 也是不怎麼優雅，
都是把上一步算好的結果再乘開，
再加這一步再除回去。自己也想不到更好的作法。
如果用分數不用浮點數，是不是就沒差，不會造成誤差了？

最後還沒有寫完，
發現還要考量第 1 層沒有上一步的情況。
太麻煩不想寫。

## tan-cf
最後一題模擬 tan 就很簡單，
要把連分數變號直接加減號就可以，
沒有特殊情況要處理 ^^
