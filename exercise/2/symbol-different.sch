
(define (variable? x) (symbol? x))
(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))
(define (make-sum a1 a2)
  (list '+ a1 a2))
(define (addend sum)
  (cadr sum))
(define (augend sum)
  (let ((else-number (cddr sum)))
    (if (= (length else-number) 1)
        (car else-number)
        (cons '+ else-number))))
(define (make-product . item)
  (if (null? item)
      1
      (cons '* item)))
(define (sum? x)
  (and (pair? x) (eq? (car x) '+)))
(define (item-sum sum) (cdr sum))
(define item-product item-sum)
(define (product? exp)
  (and (list? exp)
       (eq? '* (car exp))))
(define multiplier addend)
(define (multiplicand product)
  (let ((else-number (cddr product)))
    (if (= 1 (length else-number))
        (car else-number)
        (cons '* else-number))))
(define (make-exponentiation base hyper)
  (cond
   ((= base 0) 0)
   ((= base 1) 1)
   ((= hyper 0) 1)
   ((= hyper 1) base)
   (else (list '** base hyper))))
(define (base-exponentiation exp)
  (cadr exp))
(define (exponent-exponentiation exp)
  (caddr exp))
(define (exponent? exp)
  (and (list? exp)
       (eq? (car exp) '**)))

(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp)
         (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
          (make-product (multiplier exp)
                        (deriv (multiplicand exp) var))
          (make-product (deriv (multiplier exp) var)
                        (multiplicand exp))))
        (else
         (error "unknown expression type -- DERIV" exp))))

(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp)
         (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (apply make-sum (map (lambda (item)
                                (deriv item var))
                              (item-sum exp))))
        ((product? exp)
         (let* ((item (item-product exp))
                (first-item (car item))
                (else-item (cdr item))
                (else-product (apply make-product else-item)))
           (make-sum (make-product (deriv first-item var) else-product)
                     (make-product first-item (deriv else-product var)))))
        ((exponent? exp)
         (make-product exp
                       (log (base-exponentiation exp))
                       (deriv (exponent-exponentiation exp)
                              var)))
        (else
         (error "unknown expression type -- DERIV" exp))))

;; d c^x = d e^{ln c}^x = c^x * d x ln(c)
;; d x     d x                  d x

;; no operator piority
(define (infix->prefix infix)
  (define (operator? symbol)
    (case symbol
      ((* +) #t)
      (else #f)))
  (define (recur infix)
    (cond
     ((not (pair? infix)) infix)
     ((= 1 (length infix)) (car infix))
     (else (let ((left (car infix))
                 (operator (cadr infix))
                 (right (cddr infix)))
             (list operator
                   (recur left)
                   (recur right))))))
  (recur infix))

;; (a + b * c)
;; (a + (b * c))
;; ((a + b) * c)

;; (a * b + c)
;; ((a * b) + c)
;; (a * (b + c))
(define (prior-infix infix)
  (
